#include "lfi_linux.h"

#include <assert.h>
#include <unistd.h>
#include <sys/mman.h>

_Thread_local struct LFIContext *{{.lib}}_ctx;

struct LFIBox *{{.lib}}_box;

static const char *library_file = "{{.lib_path}}";

static void
resolve(struct LFILinuxProc *proc, lfiptr *loc, const char *name)
{
    lfiptr addr = lfi_proc_sym(proc, name);
    *loc = addr;
}

struct Buf {
    void *data;
    size_t size;
};

static struct Buf
readfile(const char *path)
{
    FILE *f = fopen(path, "r");
    if (!f) {
        fprintf(stderr, "Cannot open %s\n", path);
        return (struct Buf) { 0 };
    }
    fseek(f, 0, SEEK_END);
    size_t sz = ftell(f);
    void *p = mmap(NULL, sz, PROT_READ, MAP_PRIVATE, fileno(f), 0);
    assert(p != (void *) -1);
    fclose(f);
    return (struct Buf) {
        .data = p,
        .size = sz,
    };
}

__attribute__((constructor)) void
{{.lib}}_init(void)
{
    // Create engine if it does not exist.
    bool ok = lfi_linux_lib_init((struct LFIOptions) {
        .boxsize = 4UL * 1024 * 1024 * 1024,
        .pagesize = getpagesize(),
        .verbose = false,
    }, (struct LFILinuxOptions) {
        .stacksize = 2UL * 1024 * 1024,
        .verbose = false,
    });
    assert(ok);

    // Create proc from file.
    struct Buf prog = readfile(library_file);
    assert(prog.data);

    struct LFILinuxProc *proc = lfi_proc_new(lfi_linux_lib_engine());
    assert(proc);

    ok = lfi_proc_load(proc, prog.data, prog.size);
    assert(ok);

    // Initialize return.
    lfi_box_init_ret(lfi_proc_box(proc));

    // Initialize callbacks.
    ok = lfi_box_cbinit(lfi_proc_box(proc));
    assert(ok);

    // Create and run thread.
    const char *argv[] = {
        "{{.lib}}",
        NULL,
    };

    const char *envp[] = {
        NULL,
    };

    struct LFILinuxThread *t = lfi_thread_new(proc,
        sizeof(argv)/sizeof(argv[0]), &argv[0], &envp[0]);
    assert(t);
    int result = lfi_thread_run(t);
    assert(result == 0);

    // Initialize clone.
    lfi_linux_init_clone(t);

    // Initialize all exported symbols.
{{- range $sym := .syms}}
    extern lfiptr {{$.lib}}_addr_{{$sym}};
    resolve(proc, &{{$.lib}}_addr_{{$sym}}, "{{$sym}}");
{{- end}}

    {{.lib}}_box = lfi_proc_box(proc);
    {{.lib}}_ctx = *lfi_thread_ctxp(t);
}

void *
{{.lib}}_malloc(size_t size)
{
    return lfi_lib_malloc(&{{.lib}}_ctx, size);
}

void *
{{.lib}}_realloc(size_t size)
{
    return lfi_lib_realloc(&{{.lib}}_ctx, size);
}

void *
{{.lib}}_calloc(size_t count, size_t size)
{
    return lfi_lib_calloc(&{{.lib}}_ctx, count, size);
}

void
{{.lib}}_free(void *p)
{
    return lfi_lib_free(&{{.lib}}_ctx, p);
}
